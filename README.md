알고리즘 공부

 2020.12.14 - 프로그래머스 강의 시작
 
 <예정>
 
 백준 - 새로운 강의 런칭 후 수강 예정
 
## 프로그래머스 C++을 무기로 강의 속 문제 풀이

### C++
 - STL(Standard Template Library) 를 사용하자
 - ...


 ### 해쉬 - 완주하지 못한 선수
 
 **제한사항**
   1. 참여한 선수의 수는 1명 이상 100,000명 이하 = n이 최대 100,000
   2. 동명이인이 있을 수 있다.
   3. 선수 이름은 소문자로만 구성되어 있다.
  
  **제공 값**
   1. participant(vector<string>) : 마라톤에 참여한 선수 이름 목록
   2. completion(vector<string>) : 마라톤을 완주한 선수 이름 목록
  
  **풀이**
   - `#include<unordered_map>` 선언
   - `unordered_map<string, int> runner`선언 (Visual Studio에서 hash_map의 사용이 안된다고 한다)
   - participant의 크기만큼 반복하며 선수들을 runner에 `1씩 증가시키며` 참가자 목록을 만든다.
   - completion의 크기만큼 반복하며 선수들을 runner에서 `1씩 감소시키며` 완주자를 목록에서 제외한다.
   - 최종적으로 다시 한번 participant의 크기만큼 반복문을 통해 현재 runner에 second의 값이 `0이 아닌 것`을 찾아 return 해준다.

  **강의에서 얻은 지식**
   - map과 unordered_map의 key에 의한 접근(새로운 원소 추가, 특정 key의 value 찾기, 원소 삭제, ...) 시간은 다르다
   
      map = O(logN) :: 주로 binary search tree 사용
      
                       binary search tree = 이진 트리로 부모노드보다 작은 값은 왼쪽 노드로, 크면 오른쪽 노드로 자식을 구성한다.
                       
      unorderd_map = O(1)  :: hash_table 사용
   - unordered_map 순회하기
   
       for(auto i : runner){
       
         cout << i.first << "-" << i.second << '\n';
         
       }
       
       **해당 문제에서는 값을 참조하고 가져오기만 하면 되기 때문에 auto i 로 작성하였으나, 값을 변경해야 하면 auto &i 로 작성하는 것이 맞다.**
       
       **마찬가지로 participant와 completion의 선수 이름이 소문자와 대문자가 섞여 있으나 이를 고려하지 않는다면 lower를 사용할 때, auto &i로 써주어야 한다.**
       
   - 정렬을 통해 풀이하는 방법도 있지만, 정렬을 하는 과정이 오래 걸리기 때문에 이 문제에서는 적절하지 않다.



### 그리디 - 체육복
**탐욕법**
 알고리즘의 각 단계에서 그 순간에 최적이라고 생각되는 것을 선택하는 알고리즘
 현재의 선택이 마지막 해답의 최적성을 해치지 않을 때 선택한다. (현재 좋은게 끝에도 좋을 때)
 문제를 `정해진 순서`에 따라 살펴야 하고, 방향을 정해야 한다.

 **제한사항**
  1. 전체 학생의 수는 2명 이상 30명 이하
  2. 도난당한 학생의 수는 1명 이상 n명 이하
  3. 여분의 체육복을 가져온 학생은 1명 이상 n명 이하, 중복으로 가지고 있는 학생은 없다
  4. 여분을 가진 학생이 도난을 당하는 경우도 있다.
  
 **제공 값**
  1. lost(vector<int>) : 체육복을 잃어버린 학생 리스트
  2. reserve(vector<int>) : 여벌의 체육복을 가져온 학생 리스트
 
 **풀이**
  1. 학생의 수는 기껏해야 30명이기 때문에, 학생 수 만큼 배열을 확보하고, 각자 가지고 있는 체육복의 수를 기록한다.
  2. `순서대로` 처리하며 빌려줄 사람을 찾는다.
  3. 처음 시작 값은 모두 체육복을 가지고 있는 상태이기 때문에 1에서 시작한다.
   - 나의 풀이 에서는 새로운 백터 선언 후 반복문을 통해 1 값을 주었으나, 후에 강의를 통해 확인한 방법으로서 `vector<int> now(n+2, 1)` 과 같이 기록하면 n+2 크기의 백터에 1을 부여한다.
  4. 이후 lost의 구성에 맞춰 now 백터를 감소 시키고
  5. reserve의 구성에 맞춰 now 백터를 증가 시킨다.
  6. 이 후 now를 돌며 0 혹은 2인 값을 찾아서 빌려줄, 빌릴 방법을 찾는다.
   - 이 때, `순서대로`라는 의미를 파악하고, 이 방식을 채용하지 않을 경우 올바른 그리디 방식의 알고리즘이 나오지 않을 수 있다.
  7. now를 마지막으로 순회하며 1보다 큰 값을 가지는 개수를 파악하여 answer를 증가시키고 return한다.
  
  **추가**
   - 강의에서 해당 알고리즘은 시간복잡도 O(n)을 가지는 알고리즘이다. 만약, n이 30으로 작은 수가 아닌 엄청나게 큰 수라면? 그에 따라 시간이 오래 걸린다.
   - 하지만, 여벌을 가지고 있는 학생의 수는 매우 작다면, 다른 방식이 더욱 좋다.
   1. set과 unorderd_set을 이용하여 lost와 reserve의 값들을 새로운 집합에 넣어준다.
   2. 여벌을 가져온 학생들을 모두 `정렬`하고, 체육복이 없는 학생들을 찾아 빌려주고, set에서 제거한다.
   3. 여벌을 가져왔지만, 도난당한 학생들을 위한 set도 사용한다. (이 부분은 알고리즘을 다듬어 제거가 가능하다)
   4. 이 후 여분을 가진 학생들 중 자신의 앞, 뒤 학생이 체육복이 없다면 빌려주고 두 set에서 삭제한다.
   5. 최종적으로 `n - lostSet.size()`를 통해 정답을 도출한다.
    - 이 과정은 O(klogk)의 크기를 가진다. 기본적으로 n이 작다면 효율을 내지 못하지만, n이 크고 k가 작다면 좋은 효율을 낸다.
   
   - `#include<set>` , `#include<unordered_set>` 사용
   - set에서 사용 가능한 `find`, `erase` 등을 활용
   - `if(l.find(x) == l.end())` 의 뜻은 set l에서 x의 값이 없다는 뜻이다.
   - `if(l.find(x) != l.end())` 의 뜻은 set l에서 x의 값이 있다는 뜻이다.
  
