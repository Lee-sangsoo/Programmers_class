알고리즘 공부 (자세한 풀이는 코드  확인)

 2020.12.14 - 프로그래머스 강의 시작
 
 <예정>
 
 백준 - 새로운 강의 런칭 후 수강 예정
 
## 프로그래머스 "C++을 무기로..." 강의 속 문제 풀이 
## (프로젝트 폴더는 있으나 적히지 않은 것들은 수업 외에 따로 푼 것들이다.)

### C++
 - STL(Standard Template Library) 를 사용하자
 - ...


 ### 해쉬 - 완주하지 못한 선수
 
 **제한사항**
   1. 참여한 선수의 수는 1명 이상 100,000명 이하 = n이 최대 100,000
   2. 동명이인이 있을 수 있다.
   3. 선수 이름은 소문자로만 구성되어 있다.
  
  **제공 값**
   1. participant(vector<string>) : 마라톤에 참여한 선수 이름 목록
   2. completion(vector<string>) : 마라톤을 완주한 선수 이름 목록


### 그리디 - 체육복
**탐욕법**
 알고리즘의 각 단계에서 그 순간에 최적이라고 생각되는 것을 선택하는 알고리즘
 현재의 선택이 마지막 해답의 최적성을 해치지 않을 때 선택한다. (현재 좋은게 끝에도 좋을 때)
 문제를 `정해진 순서`에 따라 살펴야 하고, 방향을 정해야 한다.

 **제한사항**
  1. 전체 학생의 수는 2명 이상 30명 이하
  2. 도난당한 학생의 수는 1명 이상 n명 이하
  3. 여분의 체육복을 가져온 학생은 1명 이상 n명 이하, 중복으로 가지고 있는 학생은 없다
  4. 여분을 가진 학생이 도난을 당하는 경우도 있다.
  
 **제공 값**
  1. lost(vector<int>) : 체육복을 잃어버린 학생 리스트
  2. reserve(vector<int>) : 여벌의 체육복을 가져온 학생 리스트
 
 
 ### 정렬 - 가장 큰 수
**정렬**
 정렬 알고리즘은 기본적으로 O(nlogn) 보다 적게 시간이 걸리는 알고리즘은 존재하지 않는다.
 
 C++의 STL로 제공되는 `algorithm` 헤더를 통해 sort 함수를 사용한다.

 **제한사항**
  1. numbers의 길이는 1 이상 100,000 이하
  2. numbers의 원소는 0 이상 1,000 이하
  3. answer는 string으로 바꾸어 return
  
 **제공 값**
  1. numbers(vector<int>) : 가장 큰 수를 만들기 위한 숫자들이 들어있는 벡터
 
 
  ### 그리디 - 가장 큰 수
 **제한사항**
  1. number는 1자리 이상 1,000,000 자리 이하인 숫자
  2. k는 1 이상 number의 자릴수 미만인 자연수
  
 **제공 값**
  1. number(string) : 어떤 숫자
  2. k(int) : 제거해야 하는 숫자 
  
  
   ### 힙 - 더 맵게
 **정렬**
 HEAP을 구현하는 방법으로는 배열을 사용하는 방법도 있지만 (코드에 주석으로 구현해 둠)
 
 C++ STL queue의 `priority_queue`를 사용하면 된다.
 
 비교가 `greater<int>` -> 비교하여 큰게 아래로 -> Min heap
 
 비교가 `less<int>` -> 비교하여 작은게 아래로 -> Max heap
 
 **제한사항**
  1. scoville의 길이는 1 이상 1,000,000 이하
  2. k는 0 이상 1,000,000,000 이하
  3. scoville의 원소는 각각 0 이상 1,000,000 이하
  4. 불가능한 경우 -1을 return
  
 **제공 값**
  1. scoville(vector<int>) : 매움의 정도가 담긴 숫자
  2. k(int) : 최소한으로 만들어야 하는 
 
 

   ### 동적프로그래밍 - N으로 표현
 **DP**
 주어진 최적화 문제를 재귀적인 방식으로 보다 작은 부분 문제로 나누고, 부분 문제를 풀어 전체 문제의 해답에 이르는 방식
 
 탐색 해야하는 범위를 동적으로 결정한다.
 
 **제한사항**
  1. N은 1 이상 9 이하
  2. number는 1 이상 32,000 이하
  3. 괄호와 사칙연산만 가능하며, 나누기 연산에서 나머지는 무시한다.
  4. 최솟값이 8보다 크다면 -1을 return
  
 **제공 값**
  1. N(int) : 사용하는 수
  2. number(int) : 만들어야 하는 수 
  
   ### BFS/DFS - 여행경로
 **DFS, BFS**
 DFS -> stack
 
 BFS -> queue    두 방식에 차이가 조금 있다.
 
 BFS의 경우 내가 아는 그 방식이지만, DFS의 경우 조금 다르다 (헷갈리면 graph_problem의 classAnswer, myAnswer 확인하자)
