/*
작성자 : 이상수
일시 : 2021.02.02
제목 : 순위
풀이 : 그 유명한 플로이드-와샬 알고리즘을 사용하는 문제 풀이이다.
       플로이드 와샬 알고리즘 이라는 것을 들어는 보았지만 직접 구현하거나 풀어본적은
	   없었다. 그래서 이번 문제를 풀기 위해 플로이드 와샬 알고리즘을 공부하고 풀었다.

	   플로이드 와샬 알고리즘은 그래프에서 
	   '모든 정점에서 모든 정점으로의 최단 거리' 를 구하는 알고리즘이다.

	   쉽게 말해 a -> c 와 a -> b -> c 를 비교하여 더 짧은 거리를 선택하는 방식이다.

	   이 알고리즘의 구현은 정말 간단하다.

	   하지만, 3중 반복문에 있어 조금 헷갈리는 부분이 있어 찾아보았다.

	   a b c에서 왜 a를 거쳐가는 노드로 중간에 두어야 하는지 처음엔 이해가 가지 않았다.
	   플로이드 와샬 알고리즘은 
	   '하나의 거쳐가는 정점에 대해 모든 정점에서 정점으로의 거리를 확인한 다음 바꾼다'
	   라는 알고리즘 규칙 때문이다.

	   이를 확인 하고도 이해하기 힘들어서 조금 더 구글링 해보았다.
	   거쳐가는 정점을 중간 중간에 바꿔주게 되면 이 값은
	   n개의 정점 중 모든 정점을 거친 다음 목적지에 도착하는 경우가 아니라고 한다.

	   쉽게 말해 1 -> 2 -> 3 -> 4 -> 5 를 확인 해야 하지만, 1 -> 3 -> 5 와 같이 확인이 된다고 한다.
	   이 때문에 모든 경우를 확실히 확인하기 위해서는 거쳐가는 정점을 가장 바깥에 두어야 한다.
*/
#include <iostream>
#include <vector>

using namespace std;

int solution(int n, vector<vector<int>> results) {
	int answer = 0;

	vector<vector<bool>> win(n + 1, vector<bool>(n+1, false)); // 2중 반복문 사용
	 // [a][b] = a가 b를 이겼다.
	for (int i = 0; i < results.size(); i++) {
		win[results[i][0]][results[i][1]] = true; // 이긴 사람들 표시
	}

	for (int a = 1; a <= n; a++) { // 거쳐가는 정점
		for (int b = 1; b <= n; b++) { // b와 c는 출발, 도착 정점
			for (int c = 1; c <= n; c++) { // b와 c의 순서는 상관없다.
				if (win[b][a] && win[a][c]) { // b가 a를 이기고 a가 c를 이겼다면
					win[b][c] = true; // b는 c를 이긴다.
				}
			}
		}
	}

	for (int i = 1; i <= n; i++) {
		int cnt = 0;
		for (int j = 1; j <= n; j++) {
			if (win[i][j] || win[j][i]) cnt++; // i가 j를 이겼거나 // i가 j에게 졌다면
		}
		if (cnt == n - 1) answer++;
	}

	return answer;
}

int main() {
	cout << solution(8, { {1,2},{2,3},{3,4},{4,5}, {5,6},{6,7}, {7,8} });
}